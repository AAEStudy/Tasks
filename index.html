<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AAE Tasks</title>
  <!-- Load jsPsych and required plugins for both tasks -->
  <script src="js/external/jspsych.js"></script>
  <script src="js/external/plugin-preload.js"></script>
  <script src="js/external/plugin-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@1.1.4"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe@0.3"></script>
  <script src="js/external/plugin-html-multi-keyboard-response.js"></script>
  <script src="js/external/plugin-audio-multi-keyboard-response.js"></script>
  <script src="js/external/plugin-html-button-response-custom.js"></script>
  <script src="js/external/plugin-survey-likert.js"></script>
  <script src="js/external/plugin-survey-html-form.js"></script>
  <script src="js/scales.js"></script>
  <link rel="stylesheet" href="css/jspsych.css">
</head>
<body>
  <script>
    /*********************************************
     * FULL INTEGRATED EXPERIMENT SCRIPT
     * 
     * This file wraps the meditation task and the
     * metronome task as separate functions.
     * When the meditation task completes, we wipe
     * the jsPsych globals and then run the metronome
     * task.
     *********************************************/

    /***********************
     * CLEANUP FUNCTION
     ***********************/
    const queryString = window.location.search;

      // Parse the query string
    const urlParams = new URLSearchParams(queryString);
      //const subjectID = 'subject15';
      // Extract the subjectId parameter (make sure the parameter name matches what Qualtrics sends)
      
      //uncomment this line to get id from link
    let subjectID = urlParams.get('subjectID');
    let numericID; // declare numericID in the outer scope
    if (!subjectID) {
         // Generate a random 4-digit number
        subjectID = 'random' + Math.floor(10000 + Math.random() * 90000);
      } else if (subjectID.startsWith("ID")) {
        // Only extract numeric part if the ID starts with "ID"
        numericID = subjectID.slice(2);
      } else if (subjectID.startsWith("UID")) {
      // Do nothing, so numericID remains null, and we'll redirect to the regular link
        console.log("UID found, no additional id will be appended.");
      }
    // function setIDfromlink(){
    //   // Get the full query string from the URL
    //   const queryString = window.location.search;

    //   // Parse the query string
    //   const urlParams = new URLSearchParams(queryString);
    //   //const subjectID = 'subject15';
    //   // Extract the subjectId parameter (make sure the parameter name matches what Qualtrics sends)
      
    //   //uncomment this line to get id from link
    //   const subjectID = urlParams.get('subjectID');

      // Check if subjectId exists; if not, you might want to handle the error
      
   

    // You can now use 'subjectId' in your jsPsych timeline or data object as needed.

    function cleanupJsPsych() {
      // Remove the jsPsych instance and clear the experiment container.
      if (window.jsPsych) {
        window.jsPsych = null;
      }
      document.body.innerHTML = "";
    }
    // // Prevent accidental page unload.
    // function handleBeforeUnload(e) {
    //     e.preventDefault();
    //     e.returnValue = '';
    //   };
    //preload sounds for playback
    const metronomeAudio = new Audio('./sounds/metronomeMono.mp3');
    metronomeAudio.load();

    const bellAudio = new Audio('./bell.wav');
    bellAudio.load();

    

    /***********************
     * MEDITATION TASK CODE
     ***********************/
    function runMeditationTask() {
      // Set up the head and body for the meditation experiment.
      document.head.innerHTML = `
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/jspsych.css">
        <style>
          p { max-width: 750px; text-align: left; color: white; }
          h { max-width: 1200px; text-align: right; color: white; font-size: 50px; }
          body { background-color: black; }
          strong { color: white; font-weight: bold; text-decoration: underline; }
        </style>
      `;
      document.body.innerHTML = `<div id="experiment-container"></div>`;

      /****************************************************
       *              MEDITATION TASK CODE
       ****************************************************/
      // ---------------- Experiment-wide variables ----------------
      //setIDfromlink();// need to uncomment to setid
      const JSPYSCHPIPE_ID = "CEasZZbmyoOh";
      let total_exp_time = 1000 * 60 * 10; // x10 = 10 minutes
      let pauses = 0;
      let pause = false;
      let is_self_caught = false;
      let do_probe = false;
      let start_time = 0;
      let true_elapsed_time = 0;
      let effective_elapsed_time = 0;
      let accumulated_pause_time = 0;
      let accumulated_probe_time = 0;
      let pause_start = 0;
      let probe_start = 0;
      let probeData = [];
      let block_times = [];
      let curr_bell = 0;
      let probe_type = "SELF";

      // Generate random bell times.
      {
        let r = Math.random();
        let min_time = 1 * 60 * 1000; // 1 minute
        let extra_time = 0.6 * 60 * 1000;
        let time = min_time + extra_time * r;
        block_times.push(time);
        for (let i = 0; i < 4; i++) {
          let r = Math.random();
          let min_time = 1 * 60 * 1000;
          let time = block_times[i] + min_time + extra_time * r;
          extra_time += 1.6 * 60 * 1000 - (min_time + extra_time * r);
          block_times.push(time);
        }
        block_times.push(9.5 * 60 * 1000);
        console.log("Bell times (ms):", block_times);
      }

      // ---------------- Texts & Instructions ----------------
      let instructions = `<p>
          For the next ~10 minutes, you will meditate on your own without the guidance of an audio tape.
          <br><br>
          To do so, close your eyes and remain broadly focused on present moment experiences (e.g. physical sensations and feelings) and accept them as they arise.
          <br><br>
          During this time, every now and then a bell will play at which time we will ask you a couple questions.<br><br>
          Additionally, we want you to press 'M' anytime you catch yourself mind-wandering.
          <br><br>
          If something in your external environment is excessively distracting you (e.g., noises, pets, friends, etc.), you can press 'P' to pause the task and remove the distraction
          or relocate to a less distracting environment ('P' again to unpause).
          <br>
          (Note: If you have to pause more than three times and for too long we may not be able to use your data).
          <br><br>
          Press 'S' now to preview what the bell sound will sound like.
          <br><br>
          Please adjust your volume so that the bell is at a comfortable level of loudness. It should be fully present and audible but not unpleasant.
          <br><br>
          Press space to begin.
          <br>
        </p>`;
      let main_instructions = `<p style="font-size: 18pt;">
          <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          Close your eyes and remain focused on the present moment.
          <br>
          Press 'M' if you catch yourself mind-wandering.
          <br>
        </p>`;
      let wanderHTML = `<p style="font-size: 18pt;">
          Just now, what were you focused on?
          <br><br>
          1. Focused on the present moment
          <br><br>
          2. Focused on something else
        </p>`;
      let contentHTML = `<p style="font-size: 18pt;">
          Was the content of your mind-wandering?
          <br><br>
          1. Positive
          <br><br>
          2. Neutral
          <br><br>
          3. Negative
        </p>`;
      let categoryHTML = `<p style="font-size: 18pt;">
          Which category does it fall under?
          <br><br>
          1. Thoughts about the past
          <br><br>
          2. Thoughts about the future
          <br><br>
          3. Thoughts about current emotions/sensations
          <br><br>
          4. Something else
        </p>`;

      // ---------------- Initialize jsPsych ----------------
      const jsPsych = initJsPsych({
        on_finish: function () {
          console.log("Meditation experiment finished.");
          // When finished, clean up all jsPsych-related data and run the metronome task.
          cleanupJsPsych();
          runMetronomeTask();
        }
      });
      //const subjectID = jsPsych.randomization.randomID(10);
      //console.log("subjectID:", subjectID);

      // ---------------- Utility Functions ----------------
      function formatTimeShort(ms) {
        let totalSec = Math.floor(ms / 1000);
        let minutes = Math.floor(totalSec / 60);
        let seconds = totalSec % 60;
        return minutes + ":" + (seconds < 10 ? "0" + seconds : seconds);
      }
      function play_bell() {
        // Reset playback position and play the preloaded bell sound
        bellAudio.volume = 0.2;
        bellAudio.currentTime = 0;
        bellAudio.play();
      }
      
      function createEmptyRow() {
        return {
          "ParticipantID": subjectID,
          "type": "",
          "focus": "",
          "content": "",
          "category": "",
          "event_time": "",
          "mw_selfcaught": 0,
          "Self_Caught_MW Total": 0,
          "Self-Caught Positive": 0,
          "Self-Caught Neutral": 0,
          "Self-Caught Negative": 0,
          "Self-Caught Past": 0,
          "Self-Caught Future": 0,
          "Self-Caught Current Emotions/Sensations": 0,
          "Self-Caught Something Else": 0,
          "Probe_Caught Mind-Wandering": 0,
          "Probe-Caught Positive": 0,
          "Probe-Caught Neutral": 0,
          "Probe-Caught Negative": 0,
          "Probe-Caught Mindful": 0,
          "Probe-Caught Past": 0,
          "Probe-Caught Future": 0,
          "Probe-Caught Current Emotions/Sensations": 0,
          "Probe-Caught Something Else": 0,
          "pauses": 0,
          "probe_duration": "",
          "pause_duration": ""
        };
      }
      function convertWideDataToCSV(dataArray) {
        let columns = [
          "ParticipantID","type","focus","content","category","event_time","mw_selfcaught",
          "Self_Caught_MW Total","Self-Caught Positive","Self-Caught Neutral","Self-Caught Negative",
          "Self-Caught Past","Self-Caught Future","Self-Caught Current Emotions/Sensations","Self-Caught Something Else",
          "Probe_Caught Mind-Wandering","Probe-Caught Positive","Probe-Caught Neutral","Probe-Caught Negative",
          "Probe-Caught Mindful","Probe-Caught Past","Probe-Caught Future","Probe-Caught Current Emotions/Sensations","Probe-Caught Something Else",
          "pauses",
          "probe_duration",
          "pause_duration"
        ];
        let header = columns.join(",");
        let csvRows = [header];
        dataArray.forEach(rowObj => {
          let row = columns.map(colName => rowObj[colName]);
          csvRows.push(row.join(","));
        });
        return csvRows.join("\n");
      }
      function get_data_to_send() {
        return convertWideDataToCSV(probeData);
      }
      function getEffectiveTimeMS() {
        return (Date.now() - start_time) - (accumulated_pause_time + accumulated_probe_time);
      }

      // ---------------- Probe Timeline Nodes ----------------
      let probeOnset = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "",
        choices: "NO_KEYS",
        trial_duration: 1,
        on_start: function() {
          probe_start = Date.now();
        }
      };
      let wanderNode = {
        timeline: [{
          type: jsPsychHtmlKeyboardResponse,
          stimulus: wanderHTML,
          choices: ["1","2"],
          trial_duration: null,
          data: { trial_id: "wander" }
        }],
        conditional_function: function(){
          return (probe_type === "PROBE");
        }
      };
      let contentNode = {
        timeline: [{
          type: jsPsychHtmlKeyboardResponse,
          stimulus: contentHTML,
          choices: ["1","2","3"],
          trial_duration: null,
          data: { trial_id: "content" }
        }],
        conditional_function: function(){
          if(probe_type === "SELF"){
            return true;
          } else {
            let lastWander = jsPsych.data.get().filter({ trial_id: "wander" }).last(1).values()[0];
            return (lastWander && lastWander.response === "2");
          }
        }
      };
      let categoryNode = {
        timeline: [{
          type: jsPsychHtmlKeyboardResponse,
          stimulus: categoryHTML,
          choices: ["1","2","3","4"],
          trial_duration: null,
          data: { trial_id: "category" }
        }],
        conditional_function: function(){
          if(probe_type === "SELF"){
            return true;
          } else {
            let lastWander = jsPsych.data.get().filter({ trial_id: "wander" }).last(1).values()[0];
            return (lastWander && lastWander.response === "2");
          }
        }
      };
      let finalizeNode = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "",
        choices: "NO_KEYS",
        trial_duration: 1,
        on_start: function() {
          let probe_duration_ms = Date.now() - probe_start;
          accumulated_probe_time += probe_duration_ms;
          let row = createEmptyRow();
          row.type = (probe_type === "PROBE") ? "Probe" : "Self-Report";
          if(probe_type === "PROBE") {
            let lastWander = jsPsych.data.get().filter({ trial_id: "wander" }).last(1).values()[0];
            if(lastWander){
              row.focus = (lastWander.response === "1") ? "Present" : "Mind-wandering";
            }
          } else {
            row.focus = "";
          }
          let lastContent = jsPsych.data.get().filter({ trial_id: "content" }).last(1).values()[0];
          let lastCategory = jsPsych.data.get().filter({ trial_id: "category" }).last(1).values()[0];
          let contentMap = {"1":"Positive","2":"Neutral","3":"Negative"};
          let categoryMap = {"1":"Past","2":"Future","3":"Current Emotions/Sensations","4":"Something Else"};
          if((probe_type === "PROBE" && row.focus === "Mind-wandering") || probe_type === "SELF"){
            if(lastContent){
              row.content = contentMap[lastContent.response] || "";
            }
            if(lastCategory){
              row.category = categoryMap[lastCategory.response] || "";
            }
          }
          let endTime = getEffectiveTimeMS();
          row.event_time = formatTimeShort(endTime);
          row.probe_duration = (probe_duration_ms / 1000).toFixed(2);
          if(probe_type === "SELF"){
            row.mw_selfcaught = 1;
            row["Self_Caught_MW Total"] = 1;
            if(row.content === "Positive"){
              row["Self-Caught Positive"] = 1;
            } else if(row.content === "Neutral"){
              row["Self-Caught Neutral"] = 1;
            } else if(row.content === "Negative"){
              row["Self-Caught Negative"] = 1;
            }
            if(row.category === "Past"){
              row["Self-Caught Past"] = 1;
            } else if(row.category === "Future"){
              row["Self-Caught Future"] = 1;
            } else if(row.category === "Current Emotions/Sensations"){
              row["Self-Caught Current Emotions/Sensations"] = 1;
            } else if(row.category === "Something Else"){
              row["Self-Caught Something Else"] = 1;
            }
          } else {
            if(row.focus === "Present"){
              row["Probe-Caught Mindful"] = 1;
            } else if(row.focus === "Mind-wandering"){
              row["Probe_Caught Mind-Wandering"] = 1;
              if(row.content === "Positive"){
                row["Probe-Caught Positive"] = 1;
              } else if(row.content === "Neutral"){
                row["Probe-Caught Neutral"] = 1;
              } else if(row.content === "Negative"){
                row["Probe-Caught Negative"] = 1;
              }
              if(row.category === "Past"){
                row["Probe-Caught Past"] = 1;
              } else if(row.category === "Future"){
                row["Probe-Caught Future"] = 1;
              } else if(row.category === "Current Emotions/Sensations"){
                row["Probe-Caught Current Emotions/Sensations"] = 1;
              } else if(row.category === "Something Else"){
                row["Probe-Caught Something Else"] = 1;
              }
            }
          }
          probeData.push(row);
        }
      };
      let resetProbeNode = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "",
        choices: "NO_KEYS",
        trial_duration: 1,
        on_start: function() {
          probe_start = 0;
          do_probe = false;
        }
      };
      function create_probe_timeline() {
        return {
          timeline: [
            probeOnset,
            wanderNode,
            contentNode,
            categoryNode,
            finalizeNode,
            resetProbeNode
          ],
          conditional_function: function() {
            return do_probe;
          }
        };
      }
      function create_pause_trial() {
        let pause_trial = {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: "<p style='text-align:center;font-size:100px;'>⏸️</p><p><br>Press <strong>[P]</strong> to continue.</p>",
          choices: ["p"],
          on_start: function () {
            pauses++;
            pause_start = Date.now();
          },
          on_finish: function () {
            let pauseDuration = Date.now() - pause_start;
            accumulated_pause_time += pauseDuration;
            let row = createEmptyRow();
            row.type = "Pause";
            row.pauses = pauses;
            row.pause_duration = (pauseDuration / 1000).toFixed(2);
            let endTime = getEffectiveTimeMS();
            row.event_time = formatTimeShort(endTime);
            probeData.push(row);
            pause = false;
          }
        };
        return {
          timeline: [pause_trial],
          conditional_function: function () {
            return pause;
          }
        };
      }
      function get_main_instructions() {
        return "<h>" + formatTimeShort(effective_elapsed_time) + "</h>" + main_instructions;
      }
      function create_main_trial() {
        let trial = {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: get_main_instructions,
          choices: ["m", "p"],
          trial_duration: 1000,
          on_finish: function(data) {
            true_elapsed_time = Date.now() - start_time;
            effective_elapsed_time = true_elapsed_time - (accumulated_pause_time + accumulated_probe_time);
            if (effective_elapsed_time >= block_times[curr_bell]) {
              do_probe = true;
              is_self_caught = false;
              play_bell();
              probe_type = "PROBE";
              curr_bell += 1;
              return;
            }
            if (data.response === "p") {
              pause = true;
            } else if (data.response === "m") {
              is_self_caught = true;
              do_probe = true;
              probe_type = "SELF";
            }
          }
        };
        return trial;
      }
      let trial_node = {
        timeline: [
          create_main_trial(),
          create_probe_timeline(),
          create_pause_trial()
        ],
        loop_function: function () {
          return (effective_elapsed_time <= total_exp_time);
        }
      };
      let filename = subjectID + ".csv";
      let send_data = {
        type: jsPsychPipe,
        action: "save",
        experiment_id: JSPYSCHPIPE_ID,
        filename: filename,
        data_string: get_data_to_send
      };
      let final_bell_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          // Play the final bell sound
          play_bell();
          // Return the final message
          return "<p style='color:white; font-size:20pt; text-align:center;'>The meditation session is over. Please open your eyes and wait a moment for the next task to load.</p>";
        },
        choices: "NO_KEYS",
        trial_duration: 5000
      };
      let download_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<p>Do not close this tab. Thank you, the next part of the study will begin shortly.</p>`,
                      //Click the button below to download the CSV data that was sent to OSF.</p>
                     //<button id="download-btn">Download CSV</button>
        choices: "NO_KEYS",
        trial_duration: 3000,
        // on_load: function () {
        //   document.getElementById("download-btn").addEventListener("click", function () {
        //     let csv = get_data_to_send();
        //     let blob = new Blob([csv], { type: "text/csv" });
        //     let url = window.URL.createObjectURL(blob);
        //     let a = document.createElement("a");
        //     a.href = url;
        //     a.download = filename;
        //     document.body.appendChild(a);
        //     a.click();
        //     document.body.removeChild(a);
        //   });
        // }
      };
      let intro = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: instructions,
        choices: [" "],
        on_start: function () {
          document.addEventListener("keydown", preview_sound);
        },
        on_finish: function () {
          document.removeEventListener("keydown", preview_sound);
          start_time = Date.now();
        }
      };
      function preview_sound(e) {
        if (e.key === "s") {
          play_bell();
        }
      }
      let main_timeline = [
        intro,
        trial_node,
        final_bell_trial,
        send_data,
        download_trial,
      ];
      jsPsych.run(main_timeline);
    } // End of runMeditationTask

    /***********************
     * METRONOME TASK CODE
     ***********************/
    function runMetronomeTask() {
      // Set up the head and body for the metronome experiment.
      document.head.innerHTML = `
        <meta charset="UTF-8">
        <title>Metronome</title>
        <link rel="stylesheet" href="css/jspsych.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
        <style>
          body { background-color: black; }
          p { max-width: 750px; text-align: left; color: white; }
          .debrief { max-width: 750px; font-size: 18px; line-height: 1.25em; text-align: left; color: white; background-color: black; padding: 20px; }
          .probe-container { text-align: center; }
          .probe-labels,
          .probe-option,
          .probe-divider,
          .probe-instruction { color: white; }
          .probe-option { width: 150px; text-align: center; font-size: 20pt; }
          .probe-divider { width: 71.5px; text-align: center; font-size: 20pt; }
          .probe-line { width: 2px; height: 25px; background-color: white; }
          .probe-options { display: flex; justify-content: space-evenly; align-items: center; }
          .probe-instruction { margin-top: 45px; font-size: 12pt; text-align: center; width: 600px; }
          .plus { font-family: "Montserrat", sans-serif; font-size: 150px; font-weight: bold; position: absolute; transform: translate(-50%, -50%); color: #bbb; }
        </style>
      `;
      document.body.innerHTML = `<div id="experiment-container"></div>`;

      // // Prevent accidental page unload.
      // window.addEventListener('beforeunload', function(e) {
      //   e.preventDefault();
      //   e.returnValue = '';
      // });
      // var jsPsych = initJsPsych();
      // Prevent accidental page unload.
      function handleBeforeUnload(e) {
          e.preventDefault();
          e.returnValue = '';
        };

      // Add the listener using the named function
      window.addEventListener('beforeunload', handleBeforeUnload);
      var jsPsych = initJsPsych({
        on_finish: function() {
          // Add a delay before redirecting.
          setTimeout(function() {
            if (numericID) {
              // If numericID exists (subjectID started with "ID"), append it to the URL.
              window.location.replace("https://usf.az1.qualtrics.com/jfe/form/SV_eVSsVNyTwJPVr7g?id=" + numericID);
            } else {
              window.location.replace("https://usf.az1.qualtrics.com/jfe/form/SV_eVSsVNyTwJPVr7g");
            }
          }, 500);
        }
      });

      // ---------------- Global Variables & Data Storage ----------------
      //setIDfromlink();
      let trialNum = 0;  
      let probeBlockCounter = 0; //for the instructed response option
      let customData = {
        subject: [],
        trial: [],
        task: [],
        trial_num: [],
        RT_from_metronome: [],
        omission: [],
        performance_rating: [],
        probe1_rt: [],
        probe2_rt: [],
        confidence_rating: [],
        //probe_text: [],
        pause_time: [],
        break_time: [],  // <-- New field for break durations
        instructed_response: []  // New column for instructed-response data
      };
      const lag_time = 650;
      let tempPerformance = null;
      let tempProbeRT1 = null;
      let tempProbeRT2 = null;
      let pause = false;
      let pauseStart = 0;
      let justPaused = false;
      let repeatPractice = false;
      let practiceConsecutiveMisses = 0;
      let mainConsecutiveMisses = 0;
      let practiceLastRT = null;
      let mainLastRT = null;

      // ---------------- Countdown Functions ----------------
      function add_countdown(n, l=1300) {
        return {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: `<p style="font-size: 18pt;">${n}</p>`,
          response_ends_trial: false,
          trial_duration: l,
        };
      }
      function add_countdown_pad() {
        return {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: "",
          response_ends_trial: false,
          on_start: function() { leadup_ticks(); },
          trial_duration: 650
        };
      }
      function leadup_ticks() {
        setTimeout(() => { play_metronome_tick(); }, 650);
        setTimeout(() => { play_metronome_tick(); }, 650 + 1300);
        setTimeout(() => { play_metronome_tick(); }, 650 + 2*1300);
        setTimeout(() => { play_metronome_tick(); }, 650 + 3*1300);
      }

      // ---------------- Data Saving Functions ----------------
      function saveTappingTrial(score, taskType = "metronome") {
        trialNum++;
        customData.subject.push(subjectID);
        customData.trial.push(trialNum);
        customData.task.push(taskType); // will be "practice trial" or "metronome"
        customData.trial_num.push(trialNum);
        customData.RT_from_metronome.push(score);
        customData.omission.push(score === "" ? "TRUE" : "FALSE");
        customData.performance_rating.push("NA");
        customData.probe1_rt.push("NA");
        customData.probe2_rt.push("NA");
        customData.confidence_rating.push("NA");
        //customData.probe_text.push("NA");
        customData.pause_time.push("NA");
        customData.instructed_response.push("NA"); // Not applicable for tapping trials
      }
      function saveThoughtProbeTrial(confidence) {
        trialNum++;
        let probeText = (tempPerformance > 3) ? "On Task" : "Confident";
        customData.subject.push(subjectID);
        customData.trial.push(trialNum);
        customData.task.push("thought_probe");
        customData.trial_num.push(trialNum);
        customData.RT_from_metronome.push("NA");
        customData.omission.push("FALSE");
        customData.performance_rating.push(tempPerformance);
        customData.probe1_rt.push(tempProbeRT1);
        customData.probe2_rt.push(tempProbeRT2);
        customData.confidence_rating.push(confidence);
        customData.instructed_response.push("NA");
        //customData.instructed_response.push("instructed_response"); 
        //customData.probe_text.push(probeText);
        customData.pause_time.push("NA");
        tempPerformance = null;
        tempProbeRT1 = null;
        tempProbeRT2 = null;
      }
      function savePauseTrial(pauseDuration) {
        trialNum++;
        customData.subject.push(subjectID);
        customData.trial.push(trialNum);
        customData.task.push("pause");
        customData.trial_num.push(trialNum);
        customData.RT_from_metronome.push("NA");
        customData.omission.push("pause");
        customData.performance_rating.push("NA");
        customData.probe1_rt.push("NA");
        customData.probe2_rt.push("NA");
        customData.confidence_rating.push("NA");
        //customData.probe_text.push("NA");
        customData.pause_time.push(pauseDuration.toFixed(3));
        customData.instructed_response.push("NA"); // Not applicable for pause trial
      }
      function convertToCSV(dataObj) {
        let columns = Object.keys(dataObj);
        let header = columns.join("\t") + "\n";
        let numRows = dataObj[columns[0]].length;
        let rows = [];
        for (let i = 0; i < numRows; i++) {
          let row = columns.map(col => dataObj[col][i]);
          rows.push(row.join("\t"));
        }
        return header + rows.join("\n");
      }
      function play_metronome_tick() {
        metronomeAudio.currentTime = 0;
        metronomeAudio.play();
      }

      // ---------------- Pause Functionality ----------------
      let pause_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<p style='text-align:center;font-size:100px;'>⏸️</p>
                     <p style='text-align:center;'>Press <strong>[P]</strong> to continue.</p>`,
        choices: ["p"],
        response_ends_trial: true,
        trial_duration: null,
        on_start: function() {
          pauseStart = performance.now();
        },
        on_finish: function() {
          pause = false;
          justPaused = true;
          let pauseEnd = performance.now();
          let pauseSec = (pauseEnd - pauseStart) / 1000;
          savePauseTrial(pauseSec);
        }
      };
      let pause_node = {
        timeline: [pause_trial],
        conditional_function: function() { return pause; }
      };

      // ---------------- PRACTICE TAPPING ----------------
      let practice_tapping_main = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "",
        choices: [" ", "p"],
        response_ends_trial: true,
        trial_duration: 1300,
        on_start: function() {
          setTimeout(() => { play_metronome_tick(); }, 650);
        },
        on_finish: function(data) {
          if(data.response === "p") {
            pause = true;
            practiceLastRT = null; 
          } else if(data.response === " ") {
            practiceLastRT = data.rt;
          } else {
            practiceLastRT = null;
          }
        }
      };
      let practice_tapping_pad = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          if(practiceLastRT === null) {
            return "";
          }
          return '<div class="plus">+</div>';
        },
        choices: [" "],
        response_ends_trial: false,
        trial_duration: function() {
          if(practiceLastRT === null) {
            return 0;
          }
          let leftover = 1300 - practiceLastRT;
          return leftover > 0 ? leftover : 0;
        },
        on_finish: function() {
          if (pause || justPaused) {
            justPaused = false;
            return;
          }
          if(practiceLastRT === null) {
            saveTappingTrial("", "practice trial");
            practiceConsecutiveMisses++;
          } else {
            let score = practiceLastRT - lag_time;
            saveTappingTrial(score, "practice trial");
            practiceConsecutiveMisses = 0;
          }
        }
      };
      let practice_pad_node = {
        timeline: [practice_tapping_pad],
        conditional_function: function() {
          return !pause;
        }
      };

      let practice_tapping_trial = {
        timeline: [practice_tapping_main, pause_node, practice_pad_node]
      };

      let break_trial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
          <p style="color:white; font-size:20pt; text-align:left;">
            You have finished the first half of this task (10 minutes out of the 20 minute total). Nice job!<br><br>
            You may now take a short break (up to 2-3 mins max) to use the bathroom, stand up, stretch, etc. if needed.
          </p>
          <p style="color:white; text-align:center;">
            Press SPACE to continue with the second half of this task.
          </p>
        `,
        choices: [" "],
        on_start: function() {
          // Record the break start time (using a global variable or within the trial data)
          window.breakStartTime = performance.now();
        },
        on_finish: function(data) {
          // Calculate the break duration in seconds
          let breakDuration = (performance.now() - window.breakStartTime) / 1000;
          // Attach break duration to this trial’s data if you like
          data.break_duration = breakDuration;
          // And record it in your customData object
          customData.break_time.push(breakDuration.toFixed(3));
        }
      };


      let practice_miss_node = {
        timeline: [
          {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "<p>You haven't pressed SPACE for the last 4 trials.<br>Remember to press SPACE in time with the metronome.<br><br>Press SPACE to continue.</p>",
            choices: [" "],
            on_finish: function() {
              practiceConsecutiveMisses = 0;
            }
          }
        ],
        conditional_function: function() {
          return practiceConsecutiveMisses >= 4;
        }
      };
      const numPracticeTrials = 30;
      let practice_trial_counter = 0;
      let practice_block = {
        timeline: [
          {
            timeline: [practice_tapping_trial, practice_miss_node],
            loop_function: function() {
              practice_trial_counter++;
              return (practice_trial_counter < numPracticeTrials);
            }
          }
        ]
      };
      let practice_prompt = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "<p>The practice trials are now over.<br><br>If you would like to redo the practice trials, press <strong>[Left Arrow]</strong>.<br><br>If you are ready to begin the main experiment, press <strong>[Right Arrow]</strong>.</p>",
        choices: ["arrowleft", "arrowright"],
        on_finish: function(data) {
          if(data.response === "arrowleft") {
            repeatPractice = true;
            practice_trial_counter = 0;
            trialNum = 0;
            practiceConsecutiveMisses = 0;
          } else {
            repeatPractice = false;
          }
        }
      };
      let practice_node = {
        timeline: [practice_block, practice_prompt],
        loop_function: function() { return repeatPractice; }
      };
      let instructed_response_trial = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `
                <div style="text-align: center; color: white;">
                  <!-- Wrap the question text in the same container -->
                  <div style="display: inline-block; white-space: nowrap; width: 1050px; text-align: left; margin-bottom: 50px;">
                    <p style="font-size: 20pt; margin: 0;">
                      3. Select option six so we can ensure the quality of your responses.
                      </p>
                  </div>
                  <!-- The response options container -->
                  <div style="display: inline-block; width: 1050px; margin-top: 100px;">
                      <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">Least on Task</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt; display: flex; align-items: center; justify-content: center">Middle</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">Most on Task</div>
                      </div>
                      <div style="display: flex; justify-content: space-evenly; align-items: center;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">[1]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[2]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[3]</div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 2px; height: 25px; background-color: white;"></div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[4]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[5]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[6]</div>
                      </div>
                      <div style="display: flex; justify-content: center; margin-top: 150px;">
                          <div style="width: 600px; text-align: center; font-size:16pt;">
                            Please choose the instructed option so that we can ensure quality responses are being given. Press a key (1–6) for your response.</div>
                      </div>
                  </div>
                </div>`,
            choices: ["1", "2", "3", "4", "5", "6"],
            data: { instructed_response_probe: 1 },
            on_finish: function(data) {
              
              // 1) Increment your trial counter
              trialNum++;
              // 2) Add a row to customData with the actual response
              customData.subject.push(subjectID);
              customData.trial.push(trialNum);
              customData.task.push("instructed_response");
              customData.trial_num.push(trialNum);

              // Usually no tapping data for this trial:
              customData.RT_from_metronome.push("NA");
              customData.omission.push("FALSE");

              // Not a probe or pause, so push "NA" for those:
              customData.performance_rating.push("NA");
              customData.probe1_rt.push("NA");
              customData.probe2_rt.push("NA");
              customData.confidence_rating.push("NA");
              customData.pause_time.push("NA");

              // The key line: push the actual response
              customData.instructed_response.push(data.response);
            }
          };
      let main_miss_node = {
        timeline: [{
          type: jsPsychHtmlKeyboardResponse,
          stimulus: "<p>You haven't pressed SPACE for the last 4 trials.<br>Remember to press SPACE in time with the metronome.<br><br>Press SPACE to continue.</p>",
          choices: [" "],
          on_finish: function() {
            mainConsecutiveMisses = 0;
          }
        }],
        conditional_function: function() {
          return mainConsecutiveMisses >= 4;
        }
      };

      // ---------------- Thought Probe Block ----------------
      let thought_probe_block = {
        timeline: [
          {
            // Small trial to increment the counter for each probe block
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "",
            choices: "NO_KEYS",
            trial_duration: 1,
            on_start: function() {
              probeBlockCounter++;
            }
          },
          {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `
                <div style="text-align: center; color: white;">
                  <!-- Wrap the question text in the same container -->
                  <div style="display: inline-block; width: 1050px; text-align: left; margin-bottom: 50px;">
                    <p style="font-size: 20pt; margin: 0;">
                      1. How on task were you just before this screen appeared?
                    </p>
                  </div>
                  <!-- The response options container -->
                  <div style="display: inline-block; width: 1050px;">
                      <div style="display: flex; justify-content: space-between; margin-bottom: 5px; margin-top: 100px;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">Least on Task</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt; display: flex; align-items: center; justify-content: center">Middle</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">Most on Task</div>
                      </div>
                      <div style="display: flex; justify-content: space-evenly; align-items: center;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">[1]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[2]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[3]</div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 2px; height: 25px; background-color: white;"></div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[4]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[5]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[6]</div>
                      </div>
                      <div style="display: flex; justify-content: center; margin-top: 150px;">
                          <div style="width: 600px; text-align: center; font-size:16pt;">
                              Indicate how focused you were on clicking along to the metronome just before we asked. Press a key (1–6) for your response.
                            </div>
                      </div>
                  </div>
                </div>`,
            choices: ["1", "2", "3", "4", "5", "6"],
            data: { probe_question: 1, thought_probe: 1 },
            on_finish: function(data) {
              tempPerformance = data.response;
              tempProbeRT1 = (data.rt / 1000).toFixed(3);
            }
          },
          {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `
                
                <div style="text-align: center; color: white;">
                  <!-- Wrap the question text in the same container -->
                  <div style="display: inline-block; white-space: nowrap; width: 1050px; text-align: left; margin-bottom: 50px;">
                    <p style="font-size: 20pt; margin: 0;">
                      2. How confident are you in the task focus rating you just provided?
                    </p>
                  </div>
                  <!-- The response options container -->
                  <div style="display: inline-block; width: 1050px; margin-top: 100px;">
                      <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">Least Confident</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt; display: flex; align-items: center; justify-content: center">Middle</div>
                          <div style="width: 225px;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">Most Confident</div>
                      </div>
                      <div style="display: flex; justify-content: space-evenly; align-items: center;">
                          <div style="width: 150px; text-align: center; font-size:20pt;">[1]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[2]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[3]</div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 2px; height: 25px; background-color: white;"></div>
                          <div style="width: 71.5px; text-align: center; font-size:20pt;"></div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[4]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[5]</div>
                          <div style="width: 150px; text-align: center; font-size:20pt;">[6]</div>
                      </div>
                      <div style="display: flex; justify-content: center; margin-top: 150px;">
                          <div style="width: 600px; text-align: center; font-size:16pt;">
                            Indicate how certain you are your prior response accurately reflects how focused you were. Press a key (1–6) for your response.</div>
                      </div>
                  </div>
                </div>`,
            choices: ["1", "2", "3", "4", "5", "6"],
            data: { probe_question: 2, thought_probe: 1 },
            on_finish: function(data) {
              tempProbeRT2 = (data.rt / 1000).toFixed(3);
              saveThoughtProbeTrial(data.response);
            }
          },
                // Conditionally include the instructed-response trial as the third question,
          // but only on every 10th probe block.
          {
            timeline: [instructed_response_trial],
            conditional_function: function() {
              return (probeBlockCounter % 10 === 0);//only occurs when trial count is divisible by 10, so it occurs on every 10th block.
            }
          },
          {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `<p style="font-size:24pt; text-align:center;">Press the spacebar to continue and resume clicking along to the metronome.</p>`,
            choices: [" "]
          },
          {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "",
            choices: [" "],
            trial_duration: 650,
            prompt: "<img src='images/sound-icon.png'>",
            response_ends_trial: false,
            data: { thought_probe: 1 }
          }
        ]
      };
      let tapping_main = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "", 
        choices: [" ", "p"],
        response_ends_trial: true,
        trial_duration: 1300,
        on_start: function() {
          setTimeout(() => { play_metronome_tick(); }, 650);
        },
        on_finish: function(data) {
          if(data.response === "p") {
            pause = true;
            mainLastRT = null;
          } else if(data.response === " ") {
            mainLastRT = data.rt;
          } else {
            mainLastRT = null;
          }
        }
      };
      let tapping_pad = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          if(mainLastRT === null) {
            return "";
          }
          return '<div class="plus">+</div>';
        },
        choices: [" "],
        response_ends_trial: false,
        trial_duration: function() {
          if(mainLastRT === null) {
            return 0;
          }
          let leftover = 1300 - mainLastRT;
          return leftover > 0 ? leftover : 0;
        },
        on_finish: function() {
          if (pause || justPaused) {
            justPaused = false;
            return;
          }
          if(mainLastRT === null) {
            saveTappingTrial("");
            mainConsecutiveMisses++; // Increment counter on a no response
          } else {
            let score = mainLastRT - lag_time;
            saveTappingTrial(score);
            mainConsecutiveMisses = 0;  // Reset counter on a valid response
          }
        }
      };
      let main_pad_node = {
        timeline: [tapping_pad],
        conditional_function: function() {
          return !pause;
        }
      };
      let tapping_trial = {
        timeline: [tapping_main, pause_node, main_pad_node]
      };
      let countdown_main = [
        add_countdown("Main trials starting in 3..."),
        add_countdown("Main trials starting in 2..."),
        add_countdown("Main trials starting in 1..."),
        add_countdown("Go!", 650)
      ];
      function generateJitteredIntervals(numBlocks, baseTime, jitterRange) {
        let jitters = [];
        for (let i = 0; i < numBlocks; i++) {
          jitters.push(Math.random() * 2 * jitterRange - jitterRange);
        }
        const sumJitters = jitters.reduce((acc, val) => acc + val, 0);
        const avgJitter = sumJitters / numBlocks;
        const adjustedJitters = jitters.map(x => x - avgJitter);
        return adjustedJitters.map(j => baseTime + j);
      }
      
      let mrt_main = [];
      const numBlocks = 30;  // 30 blocks= 20 minutes in main trials. For quick testing; change to desired value.
      const baseTime = 40;  
      const jitterRange = 15;
      const intervals = generateJitteredIntervals(numBlocks, baseTime, jitterRange);
      for (let i = 0; i < numBlocks; i++) {
        let intervalSeconds = intervals[i];
        let nTappingTrials = Math.round((intervalSeconds * 1000) / 1300);

        // Add tapping trials for the entire block:
        for (let j = 0; j < nTappingTrials; j++) {
          mrt_main.push(tapping_trial);
          mrt_main.push(main_miss_node);  // Check and display miss screen if needed
        }
        
        // Add the thought probe for this block:
        mrt_main.push(thought_probe_block);
        
        // After finishing half the blocks, insert a break.
        // (For example, if numBlocks is 4, then after block 0 or block 1?
        // Here we use: if i === Math.ceil(numBlocks / 2) - 1) ceil rounds up no matter what the decimal is
        if (i === Math.ceil(numBlocks / 2) - 1) {
          mrt_main.push(break_trial);
          mrt_main.push(add_countdown_pad());
          mrt_main = mrt_main.concat(countdown_main);
        }
      };

      const osfSaveData = {
        type: jsPsychPipe,
        action: "save",
        experiment_id: "ZjiIhjj4eemC",
        filename: subjectID + ".tsv",
        data_string: () => convertToCSV(customData)
      };
      // function downloadCSV() {
      //   const csv = convertToCSV(customData);
      //   const blob = new Blob([csv], { type: 'text/csv' });
      //   const url = URL.createObjectURL(blob);
      //   const a = document.createElement('a');
      //   a.href = url;
      //   a.download = "experiment_data.csv";
      //   document.body.appendChild(a);
      //   a.click();
      //   document.body.removeChild(a);
      // }
        // Define each page of instructions as a string:
      // Define each page of instructions as a string:
      let instructions_pages = [
        // Page 1
        `<p>You will now do the same metronome task you did at the beginning of this study but for 20 minutes, split into two 10‑minute halves.</p>
        <p>After the first half you will be able take a short break if needed.</p>
        <p>Please refresh yourself on the instructions in the following pages.</p>
        <p>
        <p><em>Note: Make sure you fully understand the instructions before beginning. Wait for the next button to become available on each page.</em></p>`,
        
        // Page 2
        `<p>In this section of the study, you will engage in a task where you will hear a metronome sound presented at a constant rate via your headphones or external speakers.</p>
        <p>Your task will be to press the spacebar in synchrony with the onset of the metronome so that you press the spacebar exactly when each metronome sound is presented.</p>
        <p>Your accuracy is determined by how close in time your responses match the metronome and how consistent they are</p>
          <p>A plus sign will display after each time you press the spacebar to indicate that your key press registered.</p>`,
        
        // Page 3
        `<p>Every so often, the task and the metronome will temporarily stop, and you will be presented with two questions.</p>
        <p>First, a screen will ask you to indicate how on task you were just prior to us asking (within the last 15 seconds or so) on a scale from 1 (“Least on Task”) to 6 (“Most on Task”).</p>
        <p>The term “on task” refers to how focused you were on keeping your clicks in sync with the metronome versus the extent to which you were distracted or “zoned out.”</p>`,
        
        // Page 4
        `<p>It is normal for your level of focus to vary. There will be a dividing line between options 3 and 4 indicating the middle of the scale.</p>
        <p>If you were less focused than what you consider your middle or average level of focus, choose from 1–3; if more focused, choose from 4–6.</p>
        <p>Lastly, you will be presented with a screen asking you to indicate your level of confidence in your task focus response, from 1 (“Least Confident”) to 6 (“Most Confident”).</p>`,
        
        // Page 5
        `<p>Here, 1 means you were guessing and 6 means you are completely sure your response reflects your mental state just before we asked.</p>
        <p>Please use the full range of options (1–6) to indicate your relative degree of focus on clicking in time to the metronome when we ask and your level of confidence in that rating.<br></p>
         <p>This part of the experiment will take about 20 minutes. You will begin with practice trials, and then you will be notified when the main trials start.</p>
        <p>If you are ready to begin, press "Next."</p>`
      ];

      // Create a separate instructions trial for each page:
      let instructionsTrials = instructions_pages.map((pageText, index) => {
        return {
          type: jsPsychInstructions,
          pages: [pageText],
          show_clickable_nav: true,
          key_forward: null,     // Disable right arrow navigation
          key_backward: null,    // Disable left arrow navigation
          allow_backward: true, // let participants go back on pages > 1
          button_label_next: "NEXT",
          button_label_last: (index === instructions_pages.length - 1) ? "START" : "NEXT",
          on_load: function() {
            // Wait a brief moment to ensure the navigation container is rendered
            setTimeout(function(){
              // Get the navigation container (adjust the selector if needed)
              let navContainer = document.querySelector(".jspsych-instructions-nav");
              if(navContainer){
                // Get its position relative to the viewport
                let rect = navContainer.getBoundingClientRect();
                // Create an overlay that covers from the nav container's top to the bottom of the viewport
                let overlay = document.createElement("div");
                overlay.id = "instruction-overlay";
                overlay.style.position = "fixed";
                overlay.style.top = rect.top + "px";
                overlay.style.left = "0";
                overlay.style.width = "100%";
                overlay.style.height = (window.innerHeight - rect.top) + "px";
                overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                overlay.style.zIndex = "10000";
                document.body.appendChild(overlay);
                // Remove the overlay after 10 seconds
                setTimeout(function(){
                  let navButtons = document.querySelectorAll(".jspsych-instructions-nav-button");
                  navButtons.forEach(function(btn) {
                    btn.style.visibility = "visible";
                    btn.disabled = false;
                  });
                  let ov = document.getElementById("instruction-overlay");
                  if(ov){
                    ov.parentNode.removeChild(ov);
                  }
                }, 10000);
              }
            }, 100); // delay 100ms to ensure the nav is rendered
          }
        };
      });

      
//       let instructions = {
//         type: jsPsychInstructions,
//         pages: [
//           `<p> You will now do the same metronome task you did at the beginning of this study but for 20 minutes, split into two 10 minute halfs.</p>
//           <p> Please refresh yourself on the instructions below.</p>
//           <p>In this section of the study, you will engage in a task where you will hear a metronome sound presented at a constant rate via your headphones or external speakers.</p>
//           <p>Your task will be to press the spacebar in synchrony with the onset of the metronome so that you press the spacebar exactly when each metronome sound is presented.</p>
//           <p>Your accuracy for this task is determined by how close in time your responses match the metronome and how consistent your responses are in that regard.</p>
//           <p>A plus sign will display after each time you press the spacebar to indicate that your key press registered.</p>
//           <p><em>Please wait 10 seconds before clicking NEXT.</em></p>`,

//           `<p>Every so often, the task and the metronome will temporarily stop, and you will be presented with two questions.</p>
//           <p>First, a screen will ask you to indicate how on task you were just prior to us asking (within the last 15 seconds or so) on a scale from 1, “Least on Task,” to 6, “Most on Task.”</p>
//           <p>The term “on task” refers to how focused you were on keeping your clicks in sync with the metronome versus being distracted or “zoned out.”</p>
//           <p>You will respond by pressing the corresponding number on your keyboard (1–6). Answer based on your own levels of focus—where “Most on Task” is your highest level of focus and “Least on Task” is your lowest.</p>
//           <p>It is normal for your focus to vary. There will be a dividing line between options 3 and 4 indicating it is the middle of the options.</p>
//           <p>If you were less focused than your typical level, choose 1–3; if more focused, choose 4–6.<p>
//           <p>Use your overall level of focus from the first time you did this task as a reference for your typical level of task focus. 
// .</p>
//           <p><em>Please wait 10 seconds before clicking NEXT.</em></p>`,

//           `<p>Lastly, you will be presented with a screen asking you to indicate your level of confidence in your task focus response, from 1 to 6.</p>
//           <p>Here, 1 means “Least Confident” (i.e. you were guessing), and 6 means “Most Confident” (i.e. you feel completely sure your response reflects your mental state just before we asked).</p>
//           <p>Sometimes you may not perfectly recall your level of focus, and that is normal. We want you to indicate how sure you are that your rating accurately reflects your focus.</p>
//           <p>Please use the full range (1–6) for both questions. This part of the experiment will take about 20 minutes. You will begin with practice trials, and then you will be notified when the main trials start.</p>
//           <p>If you are ready to begin, press "START."</p>
//           <p><em>Please wait 10 seconds before clicking NEXT.</em></p>`
//         ],
//         show_clickable_nav: true,
//         key_forward: "arrowright",
//         key_backward: "arrowleft",
//         button_label_last: "START",
//         button_label_last_background_color: "#4CAF50",
//         button_label_last_font_color: "white",
//         on_load: function() {
//           // Disable all navigation buttons for 10 seconds on each page
//           let navButtons = document.querySelectorAll(".jspsych-instructions-nav-button");
//           navButtons.forEach(function(btn) {
//             btn.disabled = true;
//           });
//           setTimeout(function() {
//             navButtons.forEach(function(btn) {
//               btn.disabled = false;
//             });
//           }, 10000);
//         }
//       };

      // let instructions = {
      //   type: jsPsychInstructions,
      //   pages: [
      //     `<p>Please note that this part of the experiment requires <strong>headphones or speakers.</strong></p>
      //         <p>You can use the arrow keys to navigate through the instructions.<br>
      //         Press the RIGHT ARROW to continue and the LEFT ARROW to go back.</p>
      //         <p>For this experiment you will hear a metronome sound presented at a constant rate via your headphones.
      //         Your task is to press the <strong>SPACEBAR</strong> in synchrony with the metronome so that you press the spacebar exactly when the metronome sound is played.</p>
      //         <p>Your accuracy is determined by how close in time your responses are to the metronome. Sometimes you will be asked to rate how on task you were.</p>
      //         <p>If you were less focused than what you consider your middle level of focus pick and option 1-3.</p>
      //         <p>If you were more on task than your middle level of focus, then pick a number between 4-6 with respect to how on task you were.</p>
      //         <p>Please use the full range of numbers to indicate accordingly whether you were the most or least on task, just before we asked.</p>
      //         <p>If you get distracted, you may press <strong>[P]</strong> to pause (pausing will reset the current trial).</p>
      //         <p>Press "Start" to begin the practice trials.</p>`
      //   ],
      //   show_clickable_nav: true,
      //   key_forward: "arrowright",
      //   key_backward: "arrowleft",
      //   button_label_last: "START",
      //   button_label_last_background_color: "#4CAF50",
      //   button_label_last_font_color: "white"
      // };
      // let demographics = {
      //   type: jsPsychSurveyHtmlForm,
      //   preamble: "<p>Please answer the following demographic questions.</p>",
      //   html: `<hr>
      //           <p style="font-size:18px; text-align:left">
      //             <span style="margin-right:10px">I identify my gender as:</span>
      //             <input name="gender" type="text">
      //           </p>
      //           <p style="font-size:18px; text-align:left">
      //             <span style="margin-right:10px">Age:</span>
      //             <input name="age" type="text">
      //           </p>`
      // };
      let debrief = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          return `<div class="debrief">
                      <p>Do not close this tab. Thank you, the next part of the study will begin shortly.</p>
                    </div>`;
                    // <button onclick="downloadCSV()" style="font-size:18px; padding:10px; background:blue; color:white; border-radius:5px;">
                    //   Download Data
                    // </button>
        },
        choices: ["NO_KEYS"],
        trial_duration: 3000,
        on_finish: function() {
        // Remove the beforeunload listener once debrief is complete
          window.removeEventListener('beforeunload', handleBeforeUnload);
        }
      };
      let timeline = [];
      // 1. Instructions
      timeline = timeline.concat(instructionsTrials);
      // 2. Countdown before practice
      timeline.push(add_countdown_pad());
      timeline.push(add_countdown("Practice trials starting in 3..."));
      timeline.push(add_countdown("Practice trials starting in 2..."));
      timeline.push(add_countdown("Practice trials starting in 1..."));
      timeline.push(add_countdown("Go!", 650));
      // 3. Practice node
      timeline.push(practice_node);
      // 4. Countdown before main
      timeline.push(add_countdown_pad());
      timeline = timeline.concat(countdown_main);
      // 5. Main MRT block
      timeline = timeline.concat(mrt_main);
      // 6. Save data
      timeline.push(osfSaveData);
      // 7. Demographic survey
      //timeline.push(demographics);
      // 8. Debrief
      timeline.push(debrief);

      jsPsych.run(timeline);
    } // End of runMetronomeTask

    /***********************
     * START THE EXPERIMENT
     ***********************/
    runMeditationTask();
  </script>
</body>
</html>
